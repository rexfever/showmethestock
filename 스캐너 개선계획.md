# 스캐너 화면 데이터 표시 문제 개선 계획

## 📋 문제 현황

**증상:**
- 스캐너 화면에 날짜가 이상하게 표시됨
- 종가가 전날 또는 잘못된 데이터로 표시됨
- 프론트엔드에서 스캔 결과를 조회하지 못함

## 🔍 원인 분석

### 1. API 흐름 분석

#### 현재 스캔 → 저장 → 조회 플로우

```
[스케줄러]
  ↓ GET /scan?save_snapshot=true

[스캔 실행]
  ↓ api.get_ohlcv(code, 220) × 50번 (KOSPI 25 + KOSDAQ 25)
  ├─ 220일치 OHLCV 데이터 조회
  ├─ 지표 계산 (RSI, MACD, TEMA 등)
  └─ 5개 종목 매칭

[DB 저장] _save_snapshot_db()
  ├─ create_scan_rank_table(cur)  ✅ 테이블 생성
  ├─ for it in items (5개):
  │   ├─ volume = 0  ❌ it.indicators.VOL 있는데 못 찾음
  │   ├─ change_rate = 0.0  ❌ indicators에 없음
  │   └─ api.get_stock_quote(it.ticker)  ❌ 또 API 호출 × 5번
  │       └─ api.get_ohlcv(code, 2)  ← 2일치 또 조회 (중복!)
  └─ INSERT INTO scan_rank
      ├─ close_price: ✅ 정상 저장
      ├─ volume: ❌ 0으로 저장됨 (데이터 손실)
      ├─ change_rate: ❌ 0.0으로 저장됨 (데이터 손실)
      └─ indicators JSON: ✅ 모든 데이터 포함 (but change_rate 없음)

[프론트엔드 조회]
  ↓ GET /latest-scan

[DB 조회] get_latest_scan_from_db()
  ├─ ❌ create_scan_rank_table() 호출 안 함
  └─ SELECT FROM scan_rank  ← 테이블 없거나 데이터 없으면 에러
```
**왜 중복 조회?**
- `it.indicators.VOL` 있는데 못 찾아서 `volume = 0`
- `it.indicators.change_rate` 없어서 `change_rate = 0.0`
- 둘 다 0이니까 API 재조회

#### 문제 3: DB 저장 로직 오류 [P1]
**파일**: `backend/main.py` 라인 193-206
**증상**: volume과 change_rate가 0으로 저장됨

```python
def _save_snapshot_db(as_of: str, items: List[ScanItem]):
    for it in items:
        volume = 0  # ❌ 하드코딩 (it.indicators.VOL 무시)
        change_rate = 0.0  # ❌ 하드코딩

        # API 재조회로 덮어쓰기 시도하지만 실패 가능
        try:
            quote = api.get_stock_quote(it.ticker)
            if "error" not in quote:
                volume = quote.get("volume", volume)
                change_rate = quote.get("change_rate", change_rate)
        except Exception as e:
            pass  # 실패 시 0, 0.0으로 저장됨
```

**결과:**
- `volume` 컬럼: 0 저장 (데이터 손실)
- `change_rate` 컬럼: 0.0 저장 (데이터 손실)
- `indicators` JSON: VOL은 포함되지만 change_rate는 없음

#### 문제 4: 등락률/거래대금 필드 누락 [P1]
**파일**: `backend/models.py` 라인 6-17

```python
class IndicatorPayload(BaseModel):
    close: float    # ✅ 종가 있음
    VOL: int        # ✅ 거래량 있음
    # ❌ change_rate 없음 (등락률)
    # ❌ trading_value 없음 (거래대금)

    ### 3. API 호출 현황

**현재:**
```
Universe 조회:  2번 (KOSPI, KOSDAQ top codes)
스캔 실행:     50번 (get_ohlcv 220일치)
DB 저장 중복:   5번 (get_ohlcv 2일치) ← 불필요
───────────────────
합계:         57번
```

**개선 후:**
```
Universe 조회:  2번
스캔 실행:     50번
───────────────────
합계:         52번 (5번 절약)
```

## ✅ 개선 방안

### 개선 1: DB 조회 시 테이블 생성 보장 [P0 - 필수]

**목적**: 프론트엔드 조회 시 테이블 없음 에러 방지

**파일**: `backend/main.py`
**함수**: `get_latest_scan_from_db()` (라인 1537)

**수정:**
```python
def get_latest_scan_from_db():
    """DB에서 직접 최신 스캔 결과를 조회하는 함수 (SSR용)"""
    try:
        from datetime import datetime

        conn = sqlite3.connect(_db_path())
        cur = conn.cursor()

        # ✅ 추가: 테이블 생성 보장
        create_scan_rank_table(cur)

        # 오늘 날짜 확인
        today = datetime.now().strftime('%Y-%m-%d')
        # ... 기존 로직
```

**효과:**
- DB 조회 전 테이블 존재 보장
- `no such table` 에러 방지
- **수정 소요: 1줄, 1분**

---

### 개선 2: 스캔 시점에 등락률 계산 [P1 - 권장]

**목적**: API 재조회 없이 등락률 확보

**파일**: `backend/scanner.py`
**함수**: `scan_one_symbol()` (라인 509-577)

**수정:**
```python
def scan_one_symbol(code: str, base_date: str = None, market_condition=None) -> dict:
    from kiwoom_api import api
    df = api.get_ohlcv(code, config.ohlcv_count, base_date)
    # ... 기존 로직

    cur = df.iloc[-1]

    # ✅ 추가: 등락률 계산 (전일 대비)
    change_rate = 0.0
    if len(df) >= 2:
        prev_close = df.iloc[-2]["close"]
        if prev_close > 0:
            change_rate = round(((cur.close - prev_close) / prev_close) * 100, 2)

    return {
        "ticker": code,
        "name": api.get_stock_name(code),
        "match": matched,
        "score": score,
        "indicators": {
            "TEMA": cur.TEMA20,
            "DEMA": cur.DEMA10,
            # ... 기존 필드들
            "close": cur.close,
            "VOL": cur.volume,
            "change_rate": change_rate,  # ✅ 추가
        },
        # ...
    }
```

**모델 수정 필요:**
```python
# backend/models.py
class IndicatorPayload(BaseModel):
    # ... 기존 필드들
    close: float
    VOL: int
    change_rate: Optional[float] = 0.0  # ✅ 추가
```

**효과:**
- 등락률을 스캔 시점에 계산
- 이미 조회한 220일 데이터 활용
- API 재조회 불필요
- **수정 소요: 10분**

---

### 개선 3: DB 저장 시 API 재조회 제거 [P1 - 권장]

**목적**: 중복 API 호출 제거

**파일**: `backend/main.py`
**함수**: `_save_snapshot_db()` (라인 179-233)

**변경 전:**
```python
def _save_snapshot_db(as_of: str, items: List[ScanItem]):
    for it in items:
        close_price = float(getattr(it.indicators, 'close', 0))
        volume = 0  # ❌ 왜 0?
        change_rate = 0.0  # ❌ 왜 0?

        # API 재조회
        try:
            quote = api.get_stock_quote(it.ticker)  # ❌ 중복 호출
            if "error" not in quote:
                close_price = quote.get("current_price", close_price)
                volume = quote.get("volume", volume)
                change_rate = quote.get("change_rate", change_rate)
        except Exception as e:
            pass
```

**변경 후:**
```python
def _save_snapshot_db(as_of: str, items: List[ScanItem]):
    for it in items:
        # ✅ 이미 있는 데이터 사용
        close_price = float(it.indicators.close)
        volume = int(it.indicators.VOL)
        change_rate = float(getattr(it.indicators, 'change_rate', 0.0))
        market = getattr(it, 'market', '')
        strategy = it.strategy

        # ❌ API 재조회 제거
        # quote = api.get_stock_quote(it.ticker)  # 삭제
```

**효과:**
- API 호출 5회 절약
- 저장 속도 향상 (약 2~3초)
- 코드 간결화
- **수정 소요: 5분**

---

### 개선 4: 에러 처리 강화 [P2 - 선택]

**목적**: 저장 실패 원인 파악

**파일**: `backend/main.py`
**함수**: `_save_snapshot_db()` (라인 179-233)

**수정:**
```python
def _save_snapshot_db(as_of: str, items: List[ScanItem]):
    try:
        print(f"💾 데이터베이스 저장 시작: {as_of}, {len(items)}개 항목")
        conn = sqlite3.connect(_db_path())
        cur = conn.cursor()
        create_scan_rank_table(cur)

        rows = []
        for it in items:
            try:  # ✅ 추가: 개별 항목 에러 처리
                close_price = float(it.indicators.close)
                volume = int(it.indicators.VOL)
                change_rate = float(getattr(it.indicators, 'change_rate', 0.0))
                # ... 데이터 준비
                rows.append((as_of, it.ticker, ...))
            except Exception as e:
                print(f"⚠️ {it.ticker} 데이터 준비 실패: {e}")
                continue  # 실패한 항목은 건너뛰고 계속

        if not rows:  # ✅ 추가: 빈 데이터 체크
            print(f"❌ 저장할 데이터가 없습니다")
            return False

        cur.executemany("""
            INSERT OR REPLACE INTO scan_rank(...)
            VALUES (?,?,?,...)
        """, rows)
        conn.commit()
        conn.close()
        print(f"✅ 데이터베이스 저장 완료: {len(rows)}개 저장됨")
        return True

    except Exception as e:
        print(f"❌ 데이터베이스 저장 오류: {e}")
        import traceback
        traceback.print_exc()  # ✅ 상세 에러 출력
        return False
```

**효과:**
- 일부 항목 실패해도 나머지 저장
- 저장 실패 시 상세 정보 출력
- 디버깅 용이
- **수정 소요: 10분**

---

### 개선 5: 거래대금 계산 추가 [P2 - 선택]

**목적**: 스캐너 화면에 거래대금 표시

**파일**: `backend/scanner.py`
**함수**: `scan_one_symbol()` (라인 547-577)

**수정:**
```python
# ✅ 추가: 거래대금 계산 (OHLC 평균가 사용)
avg_price = (cur.open + cur.high + cur.low + cur.close) / 4
trading_value = int(avg_price * cur.volume)

return {
    "indicators": {
        # ... 기존 필드들
        "close": cur.close,
        "VOL": cur.volume,
        "change_rate": change_rate,
        "trading_value": trading_value,  # ✅ 추가: 거래대금
    }
}
```

**참고:** 거래대금 계산
- ❌ 부정확: `close × volume` (하루 중 특정 시점만 반영)
- ✅ 권장: `(open + high + low + close) / 4 × volume` (OHLC 평균가)

**모델 수정:**
```python
# backend/models.py
class IndicatorPayload(BaseModel):
    # ... 기존 필드들
    change_rate: Optional[float] = 0.0
    trading_value: Optional[int] = 0  # ✅ 추가
```

**효과:**
- 거래대금 정보 제공
- 추가 API 호출 없이 계산 (OHLC 평균가 × 거래량)
- 종가만 사용하는 것보다 정확한 근사치
- **수정 소요: 5분**

## 📊 우선순위

### P0 - 즉시 수정 (필수)
**목표**: 스캐너 화면 정상 표시

1. **개선 1**: DB 조회 시 테이블 생성 보장
   - 수정: 1줄
   - 소요: 1분
   - 효과: 테이블 없음 에러 방지

### P1 - 주요 개선 (권장)
**목표**: API 중복 제거 + 데이터 정확성

2. **개선 2**: 스캔 시점에 등락률 계산
   - 수정: scanner.py, models.py
   - 소요: 10분
   - 효과: 등락률 정확한 계산

3. **개선 3**: DB 저장 시 API 재조회 제거
   - 수정: main.py (_save_snapshot_db)
   - 소요: 5분
   - 효과: API 5회 절약, 속도 향상

### P2 - 추가 개선 (선택)
**목표**: 안정성 + 기능 확장

4. **개선 4**: 에러 처리 강화
   - 수정: main.py (_save_snapshot_db)
   - 소요: 10분
   - 효과: 디버깅 용이

5. **개선 5**: 거래대금 계산 추가
   - 수정: scanner.py, models.py
   - 소요: 5분
   - 효과: 거래대금 정보 제공

## 🔧 구현 순서

### 1단계: P0 수정 (1분)
```bash
# 1. get_latest_scan_from_db() 수정
# 파일: backend/main.py 라인 1543

# 수정 전:
conn = sqlite3.connect(_db_path())
cur = conn.cursor()

# 수정 후:
conn = sqlite3.connect(_db_path())
cur = conn.cursor()
create_scan_rank_table(cur)  # ← 이 라인 추가
```

### 2단계: 테스트 (5분)
```bash
# 백엔드 재시작
cd backend
python main.py

# 프론트엔드에서 스캐너 페이지 접속
# → 날짜/종가가 표시되는지 확인
```

### 3단계: P1 수정 (15분)
```bash
# 1. models.py 수정 - change_rate 필드 추가
# 2. scanner.py 수정 - 등락률 계산 추가
# 3. main.py 수정 - API 재조회 제거
```

### 4단계: 전체 테스트 (10분)
```bash
# 스캔 실행
curl "http://localhost:8010/scan?save_snapshot=true"

# DB 확인
cd backend
sqlite3 snapshots.db "SELECT date, code, name, close_price, volume, change_rate FROM scan_rank ORDER BY date DESC LIMIT 5"

# API 응답 확인
curl "http://localhost:8010/latest-scan" | jq '.data.items[0].indicators'
```

## 📝 테스트 체크리스트

### P0 테스트
- [ ] `/latest-scan` API 호출 시 에러 없이 응답
- [ ] 프론트엔드 스캐너 페이지에 날짜 정상 표시
- [ ] 종가/거래량 정상 표시

### P1 테스트
- [ ] 스캔 결과에 등락률(`change_rate`) 포함
- [ ] DB에 등락률 저장 확인
- [ ] API 호출 횟수 확인 (57→52 감소)
- [ ] 스캔 실행 시간 측정 (약 2~3초 단축)

### P2 테스트
- [ ] 에러 발생 시 상세 로그 출력
- [ ] 일부 종목 실패해도 나머지 저장 확인
- [ ] 거래대금 계산 정확성 확인

## ⚠️ 주의사항

### 1. 기존 데이터 마이그레이션
현재 `snapshots.db`가 비어있거나 데이터가 부족할 수 있습니다.

**해결책 A**: JSON 파일을 DB로 마이그레이션
```bash
curl -X POST http://localhost:8010/snapshots/backfill
```

**해결책 B**: 새로 스캔 실행
```bash
curl "http://localhost:8010/scan?save_snapshot=true"
```

### 2. 모델 변경 시 호환성
`IndicatorPayload`에 `change_rate` 필드 추가 시:
- `Optional[float] = 0.0`으로 기본값 설정
- 기존 데이터도 조회 가능하도록 보장

### 3. 에러 로그 모니터링
수정 후 백엔드 로그 확인:
```bash
tail -f backend/backend.log
```

다음 메시지 확인:
- `✅ 데이터베이스 저장 완료: N개 저장됨`
- `❌ 데이터베이스 저장 오류: ...` (있으면 안 됨)

### 4. 죽은 코드 정리 (선택)
현재 `enhanced_rank`와 `snapshot` 딕셔너리를 생성하지만 사용하지 않음:
```python
# backend/main.py 라인 385-454
# 이 부분은 삭제 가능 (JSON 파일 저장 안 함)
enhanced_rank = []  # ← 생성만 하고 사용 안 함
snapshot = {...}     # ← 생성만 하고 사용 안 함
```

정리하면:
- API 재조회 5번 제거
- 불필요한 데이터 가공 제거
- 코드 약 70줄 감소

## 🎯 기대 효과

### P0 적용 시 (필수)
- ✅ 스캐너 화면 정상 표시
- ✅ 날짜/종가 정상 조회
- ✅ 프론트엔드 에러 해결

### P1 적용 시 (권장)
- ✅ API 호출 57→52회 (9% 감소)
- ✅ 저장 시간 2~3초 단축
- ✅ 등락률 정확한 계산 및 저장
- ✅ 거래량 정상 저장 (현재 0으로 저장되는 문제 해결)
- ✅ 거래대금 계산 및 저장
- ✅ 코드 간결화

### P2 적용 시 (선택)
- ✅ 에러 추적 용이
- ✅ 안정성 향상
- ✅ 죽은 코드 제거 (약 70줄)

## 📌 요약

| 개선 | 우선순위 | 소요 시간 | 효과 |
|------|---------|----------|------|
| 개선 1 | P0 | 1분 | 화면 표시 정상화 (필수) |
| 개선 2 | P1 | 10분 | 등락률 계산 |
| 개선 3 | P1 | 5분 | API 5회 절약 |
| 개선 4 | P2 | 10분 | 에러 추적 강화 |
| 개선 5 | P2 | 5분 | 거래대금 표시 |
| **합계** | - | **31분** | **완전 해결** |

**최소 구현**: P0만 (1분) - 화면 표시만 복구
**권장 구현**: P0 + P1 (16분) - 데이터 정확성까지 확보
**완전 구현**: 전체 (31분) - 안정성 + 코드 품질

## ⚠️ 중요: 현재 DB 저장 상태

**현재 문제:**
```sql
-- 실제 저장되는 데이터
SELECT close_price, volume, change_rate FROM scan_rank;
-- 54600, 0, 0.0  ← volume과 change_rate가 0!
```

**원인:**
- `volume = 0`으로 하드코딩 (it.indicators.VOL 무시)
- `change_rate = 0.0`으로 하드코딩 (계산 안 함)
- API 재조회로 복구 시도하지만 실패 시 0 유지

**개선 필수:**
- P1 개선 2, 3을 적용해야 정확한 데이터 저장
- 그렇지 않으면 volume과 change_rate가 계속 0으로 저장됨