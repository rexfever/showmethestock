# 메모리 캐시의 충분성 분석

## 현재 구조에서 메모리 캐시가 충분한 이유

### 1. 서버는 계속 실행 중

**서버 운영 방식**:
- systemd로 관리되는 서비스
- `Restart=always` 설정으로 자동 재시작
- 서버가 계속 실행 중이면 프로세스도 계속 실행 중

**캐시 유지**:
```
서버 시작
  ↓
프로세스 시작 (stock-finder-backend)
  ↓
KiwoomAPI 인스턴스 생성
  ↓
_ohlcv_cache = {} (초기)
  ↓
API 호출 → 캐시 저장
  ↓
서버 계속 실행 중 (프로세스 유지)
  ↓
캐시 계속 유지 ✅
```

### 2. TTL 1년의 의미

**과거 날짜 데이터**:
- TTL: 1년 (365일)
- 서버가 1년 동안 실행 중이면 캐시 유지
- 실제로 서버는 계속 실행 중이므로 캐시가 오래 유지됨

**예시**:
```python
# 2025-01-01: API 호출, 캐시 저장
api.get_ohlcv("005930", 220, "20250101")

# 2025-06-01: 같은 프로세스 (서버 계속 실행 중)
api.get_ohlcv("005930", 220, "20250101")
# → 캐시 히트 ✅ (TTL 1년, 아직 유효)
```

### 3. 프로세스 재시작이 드묾

**재시작이 발생하는 경우**:
1. 배포 시 (수동 또는 자동)
2. 서비스 재시작 (수동)
3. 오류로 인한 자동 재시작

**빈도**:
- 배포: 하루에 몇 번 이하
- 서비스 재시작: 거의 없음
- 자동 재시작: 오류 발생 시에만

**결론**: 프로세스 재시작이 드물므로 캐시 소실도 드묾

---

## 메모리 캐시가 충분한 시나리오

### 시나리오 1: 일반적인 API 호출

```python
# 서버 실행 중
GET /scan?date=20251001
  → api.get_ohlcv("005930", 220, "20251001")
  → API 호출, 캐시 저장

# 같은 프로세스 내 재호출
GET /scan?date=20251001
  → api.get_ohlcv("005930", 220, "20251001")
  → 캐시 히트 ✅ (API 호출 없음)
```

**결과**: 메모리 캐시로 충분

### 시나리오 2: 여러 날짜 스캔

```python
# 여러 날짜 스캔
for date in ["20251001", "20251002", "20251003"]:
    GET /scan?date={date}
      → 각 날짜별로 캐시 저장

# 이후 재스캔
for date in ["20251001", "20251002", "20251003"]:
    GET /scan?date={date}
      → 모두 캐시 히트 ✅
```

**결과**: 메모리 캐시로 충분

### 시나리오 3: 스케줄러 실행

```python
# 스케줄러가 매일 스캔 실행
# 같은 프로세스 내에서 실행
scheduler.run()
  → api.get_ohlcv("005930", 220, "20251001")
  → 캐시 저장

# 다음 날 같은 종목 스캔
scheduler.run()
  → api.get_ohlcv("005930", 220, "20251002")
  → 새 데이터 캐시 저장
  → 이전 날짜는 캐시에 유지 ✅
```

**결과**: 메모리 캐시로 충분

---

## 메모리 캐시가 부족한 시나리오

### 시나리오 1: 백테스트 (별도 스크립트)

```python
# 백테스트 스크립트 실행 (새 프로세스)
python backtest.py
  → api = KiwoomAPI()  # 새 인스턴스
  → _ohlcv_cache = {}  # 비어있음
  → API 호출 필요 ❌
```

**문제**: 별도 프로세스이므로 캐시 없음

### 시나리오 2: 프로세스 재시작 후

```python
# 배포로 인한 재시작
sudo systemctl restart stock-finder-backend

# 새 프로세스
api = KiwoomAPI()  # 새 인스턴스
_ohlcv_cache = {}  # 비어있음

# 첫 요청
GET /scan?date=20251001
  → API 호출 필요 ❌
```

**문제**: 프로세스 재시작 시 캐시 소실

### 시나리오 3: 멀티 워커 (향후 확장 시)

```python
# --workers 4로 변경
워커 1: api1.get_ohlcv() → 캐시 저장
워커 2: api2.get_ohlcv() → 캐시 없음 (다른 인스턴스)
```

**문제**: 워커별로 캐시 분리

---

## 결론

### 메모리 캐시가 충분한 경우

✅ **일반적인 서버 운영**:
- 서버가 계속 실행 중
- 같은 프로세스 내에서 API 호출
- 스케줄러 실행
- 여러 날짜 스캔

**이유**:
- 프로세스가 계속 실행 중이므로 캐시 유지
- TTL 1년이면 오래 유지
- 프로세스 재시작이 드묾

### 메모리 캐시가 부족한 경우

❌ **백테스트 (별도 스크립트)**:
- 새 프로세스에서 실행
- 캐시 없음

❌ **프로세스 재시작 후**:
- 배포 시 캐시 소실
- 첫 요청 시 API 호출 필요

❌ **멀티 워커 (향후)**:
- 워커별로 캐시 분리

---

## 권장사항

### 현재 구조에서는 메모리 캐시로 충분

**이유**:
1. 서버가 계속 실행 중
2. 프로세스 재시작이 드묾
3. 같은 프로세스 내에서 캐시 공유
4. TTL 1년으로 오래 유지

### 디스크 캐시는 선택사항

**필요한 경우**:
- 백테스트를 별도 스크립트로 자주 실행
- 프로세스 재시작 후에도 캐시 유지 필요
- 멀티 워커로 확장 예정

**현재는 불필요**:
- 서버가 계속 실행 중
- 일반적인 API 호출만 사용
- 프로세스 재시작이 드묾

---

## 요약

| 시나리오 | 메모리 캐시 충분? | 이유 |
|---------|----------------|------|
| 일반적인 API 호출 | ✅ 충분 | 같은 프로세스 내 캐시 공유 |
| 스케줄러 실행 | ✅ 충분 | 같은 프로세스 내 실행 |
| 여러 날짜 스캔 | ✅ 충분 | 캐시에 저장되어 재사용 |
| 백테스트 (별도 스크립트) | ❌ 부족 | 새 프로세스, 캐시 없음 |
| 프로세스 재시작 후 | ❌ 부족 | 캐시 소실 |
| 멀티 워커 | ❌ 부족 | 워커별 캐시 분리 |

**결론**: 현재 구조에서는 메모리 캐시로 충분합니다. 디스크 캐시는 백테스트나 멀티 워커 확장 시에만 필요합니다.

