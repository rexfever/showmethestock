# OHLCV 캐시 23시 조회 시나리오 분석

## 시나리오: 23시에 조회

### 상황
- **시간**: 23:00 (장 마감 후)
- **조회**: `get_ohlcv("005930", 220, None)`
- **데이터**: 당일 장 마감 데이터 (예: 2025-11-24)

## 동작 흐름

### 1. 첫 번째 조회 (23:00)

```
2025-11-24 23:00: get_ohlcv("005930", 220, None)
  ↓
장 마감 후 확인 → TTL: 24시간
  ↓
API 호출 → 2025-11-24 데이터 조회
  ↓
캐시 저장 (TTL: 24시간, 만료 시각: 2025-11-25 23:00)
```

### 2. 24시간 후 재조회 (다음날 23:01)

```
2025-11-25 23:01: get_ohlcv("005930", 220, None)
  ↓
캐시 확인: _get_cached_ohlcv()
  ↓
DataFrame의 마지막 날짜 확인: "20251124"
  ↓
2025-11-24 < 2025-11-25 (과거 날짜)
  ↓
TTL 재계산: _calculate_ttl("20251124")
  ↓
과거 날짜 → TTL: 1년 (365일)
  ↓
캐시에서 반환 (24시간이 지났지만 1년 TTL로 유효)
```

## 문제점 및 해결

### 문제점
- 23시에 조회한 데이터는 당일 데이터
- 24시간 후에는 이미 어제 데이터가 됨
- 하지만 `base_dt=None`이면 여전히 "현재 날짜"로 인식될 수 있음

### 해결 (구현 완료)
- `_get_cached_ohlcv()`에서 DataFrame의 실제 날짜 확인
- 실제 날짜가 과거면 자동으로 1년 캐싱 적용
- `base_dt=None`이어도 최적화된 캐싱 가능

## 시나리오별 동작

### 시나리오 1: 23시 조회 → 24시간 후 재조회

```
2025-11-24 23:00: 조회
  → 데이터: 2025-11-24
  → 캐시 저장 (TTL: 24시간)

2025-11-25 23:01: 재조회
  → 캐시 확인: DataFrame 날짜 = "20251124"
  → 과거 날짜로 인식
  → TTL: 1년 적용
  → 캐시에서 반환 ✅
```

### 시나리오 2: 23시 조회 → 다음날 09시 재조회 (장중)

```
2025-11-24 23:00: 조회
  → 데이터: 2025-11-24
  → 캐시 저장 (TTL: 24시간)

2025-11-25 09:00: 재조회 (장중)
  → 캐시 확인: DataFrame 날짜 = "20251124"
  → 과거 날짜로 인식
  → TTL: 1년 적용
  → 캐시에서 반환 ✅
```

### 시나리오 3: 23시 조회 → 같은 날 23:30 재조회

```
2025-11-24 23:00: 조회
  → 데이터: 2025-11-24
  → 캐시 저장 (TTL: 24시간)

2025-11-24 23:30: 재조회
  → 캐시 확인: DataFrame 날짜 = "20251124"
  → 현재 날짜로 인식 (아직 같은 날)
  → TTL: 24시간 (장 마감 후)
  → 캐시에서 반환 ✅
```

## 최적화 효과

### Before (개선 전)
```
2025-11-24 23:00: 조회 → 캐시 저장 (TTL: 24시간)
2025-11-25 23:01: 재조회 → 캐시 만료 → 재조회 ❌
```

### After (개선 후)
```
2025-11-24 23:00: 조회 → 캐시 저장 (TTL: 24시간)
2025-11-25 23:01: 재조회 → 과거 날짜로 인식 → TTL: 1년 → 캐시에서 반환 ✅
```

## 결론

**23시 조회 시**:
1. ✅ 당일 데이터 조회 및 캐시 저장 (TTL: 24시간)
2. ✅ 24시간 후 재조회 시 과거 날짜로 자동 인식
3. ✅ 1년 캐싱으로 전환되어 불필요한 재조회 방지
4. ✅ `base_dt=None`이어도 최적화된 캐싱 적용

**핵심**: DataFrame의 실제 날짜를 확인하여 과거 데이터는 자동으로 장기 캐싱 적용

