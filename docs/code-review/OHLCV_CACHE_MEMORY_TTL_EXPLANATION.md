# 메모리 캐시 TTL과 프로세스 재시작 관계

## 질문

**"메모리 캐시는 TTL이 1년이라도 재실행 시는 사라지나?"**

## 답변

### ✅ 네, 완전히 사라집니다

**TTL 1년의 의미**:
- 프로세스가 **실행 중**일 때: 1년 동안 캐시 유지
- 프로세스 **재시작** 시: **캐시 완전히 소실** (TTL과 무관)

---

## 메모리 캐시의 특성

### 1. 저장 위치

```python
# KiwoomAPI.__init__()
self._ohlcv_cache: Dict[Tuple, Tuple[pd.DataFrame, float]] = {}
```

- **저장 위치**: 프로세스의 RAM (메모리)
- **생명주기**: 프로세스와 동일

### 2. 프로세스 종료 시

```
프로세스 시작
  ↓
KiwoomAPI 인스턴스 생성
  ↓
_ohlcv_cache = {} (빈 딕셔너리)
  ↓
get_ohlcv() 호출 → API 호출 → 캐시 저장
  ↓
_ohlcv_cache = {("005930", 220, "20251001", None): (df, timestamp)}
  ↓
프로세스 종료
  ↓
메모리 해제 → _ohlcv_cache 완전히 소실
```

### 3. 프로세스 재시작 시

```
새 프로세스 시작
  ↓
새 KiwoomAPI 인스턴스 생성
  ↓
_ohlcv_cache = {} (다시 빈 딕셔너리)
  ↓
이전 캐시는 완전히 사라짐
```

---

## TTL의 실제 의미

### TTL 1년이 의미하는 것

```python
def _calculate_ttl(self, base_dt: Optional[str]) -> int:
    if base_dt:
        base_date = datetime.strptime(base_dt, "%Y%m%d").date()
        now_date = datetime.now().date()
        if base_date < now_date:
            return 365 * 24 * 3600  # 1년
```

**의미**:
- 프로세스가 **1년 동안 실행 중**이면 캐시 유지
- 프로세스가 **종료되면** TTL과 무관하게 캐시 소실

### 예시

```python
# 시나리오 1: 프로세스 실행 중
api = KiwoomAPI()
df1 = api.get_ohlcv("005930", 220, "20251001")  # API 호출, 캐시 저장

# 6개월 후 (같은 프로세스)
df2 = api.get_ohlcv("005930", 220, "20251001")  # ✅ 캐시 히트 (TTL 1년)

# 시나리오 2: 프로세스 재시작
# 프로세스 종료 → 재시작
api2 = KiwoomAPI()  # 새로운 인스턴스
df3 = api2.get_ohlcv("005930", 220, "20251001")  # ❌ API 호출 (캐시 없음)
```

---

## 메모리 vs 디스크 캐시 비교

### 메모리 캐시 (현재 구현)

| 항목 | 설명 |
|------|------|
| **저장 위치** | RAM (프로세스 메모리) |
| **생명주기** | 프로세스와 동일 |
| **프로세스 종료 시** | 완전히 소실 |
| **프로세스 재시작 후** | 비어있음 (새로 시작) |
| **TTL 의미** | 프로세스 실행 중 유효 기간 |

### 디스크 캐시 (개선 방안)

| 항목 | 설명 |
|------|------|
| **저장 위치** | 디스크 (파일 시스템) |
| **생명주기** | 파일이 삭제될 때까지 |
| **프로세스 종료 시** | 유지됨 |
| **프로세스 재시작 후** | 로드 가능 |
| **TTL 의미** | 파일 유효 기간 |

---

## 실제 동작 예시

### 예시 1: 같은 프로세스 내

```python
# 스크립트 실행
api = KiwoomAPI()

# 첫 호출
df1 = api.get_ohlcv("005930", 220, "20251001")
# → API 호출
# → _ohlcv_cache[("005930", 220, "20251001", None)] = (df, timestamp)

# 두 번째 호출 (같은 프로세스)
df2 = api.get_ohlcv("005930", 220, "20251001")
# → 캐시 확인: 존재함
# → TTL 확인: 1년 (유효)
# → 캐시에서 반환 (API 호출 없음) ✅
```

### 예시 2: 프로세스 재시작

```python
# 스크립트 1 실행
api1 = KiwoomAPI()
df1 = api1.get_ohlcv("005930", 220, "20251001")  # API 호출, 캐시 저장
# 스크립트 종료 → 프로세스 종료 → 메모리 해제

# 스크립트 2 실행 (새 프로세스)
api2 = KiwoomAPI()  # _ohlcv_cache = {} (비어있음)
df2 = api2.get_ohlcv("005930", 220, "20251001")
# → 캐시 확인: 없음
# → API 호출 필요 ❌
```

---

## 결론

### 메모리 캐시의 한계

1. **프로세스 종료 = 캐시 소실**
   - TTL 1년이어도 프로세스가 종료되면 캐시는 사라짐
   - TTL은 "프로세스 실행 중 유효 기간"일 뿐

2. **프로세스 재시작 = 캐시 없음**
   - 새 프로세스는 빈 캐시로 시작
   - 이전 캐시는 완전히 소실

3. **백테스트 시 문제**
   - 스크립트 실행 → 종료 → 재실행 시마다 API 호출 필요
   - TTL 1년이어도 프로세스 재시작 후에는 의미 없음

### 해결 방안

**디스크 캐시 추가**가 필요합니다:
- 프로세스 재시작 후에도 캐시 유지
- 백테스트 시 API 호출 없이 실행 가능

---

## 요약

| 질문 | 답변 |
|------|------|
| TTL 1년이면 프로세스 재시작 후에도 유지되나? | ❌ 아니요, 완전히 사라집니다 |
| 왜 사라지나? | 메모리 캐시는 프로세스 RAM에만 저장되므로 |
| TTL 1년의 의미는? | 프로세스가 1년 동안 실행 중일 때 유효 |
| 프로세스 재시작 후에는? | 항상 API 호출 필요 |

